<!DOCTYPE html>
<html>
<head>
<title>jig.jp インターン2024 選考課題</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<style>
  html {
    display: flex;
    justify-content: center;
  }
  body {
    width: 100vw;
    max-width: 700px;
    background-color: #EEE;
    color: #4d4d4d;
  }
  img {
    width: 80%;
    margin-left: 5%;
    outline: solid #4d4d4d;
  }
  h2 {
    counter-reset: section;

    margin-top: 30px;
    padding-left: 10px;
    border-left: 0.1em solid #4d4d4d;
  }
  h3 {
    font-weight: bold;
  }
  h3::before {
    counter-increment: section;
    content: "（" counter(section) "） ";
  }
  h4 {
    font-size: 1em;
    padding-left: 0.6em;
  }
  h4::before {
    content: "> ";
  }
  p {
    padding-left: 0.6em;
  }
</style>
<h1 id="%E3%81%97%E3%82%8A%E3%81%A8%E3%82%8A%E3%82%A2%E3%83%97%E3%83%AA%E3%82%92%E4%BD%9C%E3%81%A3%E3%81%A6%E3%81%BF%E3%82%88%E3%81%86">jig.jp インターン2024 選考課題</h1>
<h2 id="%E3%81%AF%E3%81%98%E3%82%81%E3%81%AB">はじめに</h2>
<p>今回のインターンシップの選考課題では、「しりとりアプリ」を実装して提出していただきます。<br>
使用言語やフレームワークに制限はありませんので、得意な環境で取り組んでください。</p>
<h2 id="%E8%AA%B2%E9%A1%8C%E5%86%85%E5%AE%B9">課題内容</h2>
<p>「しりとりアプリ」を実装して提出してください。詳細を以下に示します。</p>
<h3 id="%E6%8F%90%E5%87%BA%E7%89%A9">提出物</h3>
<p>ソースコードと<code>README</code>を掲載したGitHubリポジトリのリンクと、成果物を提出してください。<br>
成果物のフォーマットは問いませんので、実行ファイルやデプロイされたWebアプリのURL等、動作が確認できるものを提出してください。また、確認用に特殊な環境が必要な場合は、事前に相談してください。</p>
<p>また、<code>README</code>には以下の内容を記述してください。</p>
<ul>
<li>実装した機能やデザインの説明</li>
<li>アプリの動作確認の方法（WebサイトのURLや、セットアップを含めたアプリケーションの実行手順等）</li>
<li>参考にしたWebサイト</li>
</ul>
<h3 id="%E4%BB%95%E6%A7%98">仕様</h3>
<p>最低限、以下の仕様を満たすように実装してください。</p>
<ul>
<li>直前の単語を、表示できるようにする</li>
<li>任意の単語を、入力できるようにする</li>
<li>直前の単語の末尾と、入力した単語の先頭を比較して、同じ場合だけ単語を更新する。違う場合は、エラーを表示する</li>
<li>末尾が「ん」で終わる単語が入力されたら、ゲームを終了する</li>
<li>過去に使用した単語が入力されたら、ゲームを終了する</li>
<li>ゲーム中や終了後に、最初からやり直せるリセット機能をつける</li>
</ul>
<p>また、便利・面白いと思う任意の機能を考えて実装してください。実装する機能の個数は問いません。<br>
以下に例を示しますが、他に機能を思いついた場合は、自由に実装してみてください。</p>
<ul>
<li>最初の単語がランダムに決まるようにする</li>
<li>一文字のものや絵文字等、しりとりとして不適切な単語は入力できないようにする</li>
<li>ひらがな以外は入力できないようにする</li>
<li>実在しない単語は入力できないようにする</li>
<li>しりとりの単語の履歴を表示できるようにする</li>
<li>複数のユーザーが対戦できるようにする</li>
</ul>
<p>実装した内容は、<code>README</code>に記載してください。</p>
<h3 id="%E5%AE%9F%E8%A3%85%E7%92%B0%E5%A2%83">実装環境</h3>
<p>使用する言語やフレームワークの指定は、特にありません。得意なものや、気になっているものを使用して実装してください。<br>
特に環境に拘りの無い方は、以下にDenoを使用して途中まで実装した例を示しますので、Denoを使用して実装してみてください。</p>
<h2 id="step-0-github%E3%82%A2%E3%82%AB%E3%82%A6%E3%83%B3%E3%83%88%E3%81%AE%E4%BD%9C%E6%88%90">Step 0. GitHubアカウントの作成</h2>
<blockquote>
<p>GitHubアカウント作成後、数日経過しなければ使用できない機能もあるため、早めに登録することをおすすめします。</p>
</blockquote>
<p>作成したWebアプリケーションの提出等に必要なため、GitHubアカウントを作成しましょう。<br>
以下のWebサイトからアカウント登録を行ってください。</p>
<blockquote>
<p>注意！
GitHubのアカウントを複数持つことは利用規約で禁止されています。既にアカウントをお持ちの方は、そちらのアカウントをご利用ください。</p>
</blockquote>
<p><a href="https://github.com/">https://github.com/</a></p>
<h2 id="step-1-deno%E3%81%AE%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB">Step 1. Denoのインストール</h2>
<h3 id="deno-%E3%83%87%E3%82%A3%E3%83%BC%E3%83%8E-%E3%81%A8%E3%81%AF">Deno (ディーノ) とは</h3>
<p>Denoは、JavaScript/TypeScriptの実行環境(ランタイム)です。これらの言語でサーバーの処理を実装できます。<br>
ここでは、入門者向けとしてJavaScriptを使用します。TypeScriptの使用方法が分かる方は、そちらを使用していただいても問題ありません。</p>
<p>Webフロントエンドで多く用いられるJavaScriptを使用するため、フロントエンドとバックエンドを同一言語で実装できます。<br>
DenoはNode.jsの作者であるライアン・ダール氏によって実装されたランタイムで、Node.jsをブラッシュアップしたものとなっています。</p>
<blockquote>
<p>Denoという名前は、Nodeのアナグラムだそうですよ！</p>
</blockquote>
<h3 id="deno%E3%81%AE%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB">Denoのインストール</h3>
<p>公式サイトの説明に従い、Denoをインストールしてみましょう。</p>
<p><a href="https://docs.deno.com/runtime/manual">https://docs.deno.com/runtime/manual</a></p>
<p>「Install Deno」の項目に記載されたコマンドをご自身のOSに合わせて実行するだけで、インストールが可能です。<br>
インストールが完了したら、以下のコマンドを実行してみましょう。バージョン情報が表示されればOKです！</p>
<pre class="hljs"><code><div><span class="hljs-comment"># 入力</span>
deno --version

<span class="hljs-comment"># 出力</span>
<span class="hljs-comment"># deno 1.42.2 (release, aarch64-apple-darwin)</span>
<span class="hljs-comment"># v8 12.3.219.9</span>
<span class="hljs-comment"># typescript 5.4.3</span>
</div></code></pre>
<h3 id="deno%E3%81%A7hello-world">DenoでHello World</h3>
<p>Hello Worldプログラムを作って実行してみましょう。<br>
空のフォルダを作り、中に <code>server.js</code> を作成して、以下のプログラムを書き込んでください。</p>
<pre class="hljs"><code><div>console.log(&quot;Hello World!&quot;);
</div></code></pre>
<p>保存が完了したら、Denoで実行してみましょう！</p>
<pre class="hljs"><code><div>deno run server.js

<span class="hljs-comment"># Hello World!</span>
</div></code></pre>
<h2 id="step-2-visual-studio-code%E3%81%AE%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB%E3%83%BB%E3%82%BB%E3%83%83%E3%83%88%E3%82%A2%E3%83%83%E3%83%97">Step 2. Visual Studio Codeのインストール・セットアップ</h2>
<h3 id="visual-studio-code%E3%81%A8%E3%81%AF">Visual Studio Codeとは</h3>
<p>Microsoftが提供しているソースコードエディタです。VS Codeとも呼ばれます。<br>
開発に必要な機能の多くを搭載しており、プラグインの開発も企業・個人問わず行われているので、特に拘りが無ければインストールをおすすめします。</p>
<p>既にお気に入りのエディタがある場合は、インストールせずに進めていただいても構いません。</p>
<h3 id="visual-studio-code%E3%81%AE%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB">Visual Studio Codeのインストール</h3>
<p>公式サイトの説明に従い、Visual Studio Codeをインストールしてみましょう。</p>
<p>https://code.visualstudio.com/</p>
<p>ご自身のOSに合わせたものをダウンロードして、インストールしましょう。</p>
<h3 id="deno%E3%81%AE%E6%8B%A1%E5%BC%B5%E6%A9%9F%E8%83%BD%E3%82%92%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB">Denoの拡張機能をインストール</h3>
<p>VS CodeにDenoの拡張機能をインストールしましょう。画面左側の「Extensions」アイコンから拡張機能の画面を開き、「Deno」で検索して、インストールしてください。</p>
<p><img src="./imgs/01_vscode-deno-install.png" alt=""></p>
<h3 id="deno%E3%81%AE%E6%8B%A1%E5%BC%B5%E6%A9%9F%E8%83%BD%E3%82%92%E3%82%BB%E3%83%83%E3%83%88%E3%82%A2%E3%83%83%E3%83%97">Denoの拡張機能をセットアップ</h3>
<p><code>server.js</code>を作成したフォルダで、Denoの拡張機能の設定を行いましょう。「Control+Shift+P」でコマンドパレットを開き、「Deno: Initialize Workspace Configuration」を実行します。<br>
<code>.vscode/settings.json</code>が作成され、Deno関連の補完が効くようになったらOKです。</p>
<p><img src="./imgs/02_vscode-deno-setup.png" alt=""></p>
<p><img src="./imgs/03_vscode-deno-setup-check.png" alt=""></p>
<h2 id="step-3-deno%E3%81%A7http%E3%82%B5%E3%83%BC%E3%83%90%E3%83%BC%E3%82%92%E7%AB%8B%E3%81%A6%E3%81%A6%E3%81%BF%E3%82%88%E3%81%86">Step 3. DenoでHTTPサーバーを立ててみよう</h2>
<p>DenoでHTTPサーバーを立ち上げてみましょう。</p>
<p>HTTPサーバーとは、HTTP (HyperText Transfer Protocol) に則って通信するサーバーです。<br>
HTTPサーバー上に処理やデザイン等を記述することで、様々なWebアプリを動作させられます。<br>
Denoが提供している<code>serve</code>関数を利用することで、簡単にHTTPサーバーを立ち上げることができます。</p>
<p>以下に実装と作動の手順を示します。</p>
<ol>
<li><code>server.js</code>の内容を以下のように書き換えて保存してください。</li>
</ol>
<pre class="hljs"><code><div>// server.js

// localhostにDenoのHTTPサーバーを展開
Deno.serve(request =&gt; {
    return new Response(&quot;Hello Deno!&quot;);
});
</div></code></pre>
<ol start="2">
<li><code>--allow-net</code>オプションをつけて<code>server.js</code>を起動してください。このオプションがない場合、Denoがネットワークにアクセスできません。</li>
</ol>
<pre class="hljs"><code><div>deno run --allow-net server.js
</div></code></pre>
<ol start="3">
<li>
<p>ブラウザで<code>http://localhost:8000</code>にアクセスしてみましょう。</p>
</li>
<li>
<p>ブラウザに<code>Hello Deno!</code>と表示されればOKです！</p>
</li>
</ol>
<p><img src="./imgs/04_tutorial-hello-deno.png" alt=""></p>
<ol start="5">
<li>動作が確認できたら、「Control+C」でプログラムを終了します。</li>
</ol>
<h2 id="step-4-%E3%82%B5%E3%83%BC%E3%83%90%E3%83%BC%E3%81%AB%E5%A4%89%E6%95%B0%E3%82%92%E5%AE%9A%E7%BE%A9%E3%81%97%E3%81%A6%E3%81%BF%E3%82%88%E3%81%86">Step 4. サーバーに変数を定義してみよう</h2>
<p>HTTPサーバー上にアクセス数をカウントする変数を追加して、アクセス数を確認してみましょう。</p>
<ol>
<li><code>server.js</code>ファイルを以下の内容で編集します。</li>
</ol>
<pre class="hljs"><code><div>  // server.js
<span class="hljs-addition">+ // アクセス数を保持する変数をグローバル領域に定義</span>
<span class="hljs-addition">+ let count = 0;</span>
<span class="hljs-addition">+ </span>
  // localhostにDenoのHTTPサーバーを展開
  Deno.serve(request =&gt; {
<span class="hljs-deletion">-     return new Response("Hello Deno!");</span>
<span class="hljs-addition">+     count++;</span>
<span class="hljs-addition">+     return new Response(`Count: ${count}`);</span>
  });
</div></code></pre>
<ol start="2">
<li><code>--allow-net</code>に加えて、<code>--watch</code>オプションを追加して<code>server.js</code>を起動してください。このオプションを指定すると、Denoがファイルの変更を自動でサーバーに反映してくれます。</li>
</ol>
<pre class="hljs"><code><div>deno run --allow-net --watch server.js
</div></code></pre>
<ol start="3">
<li>
<p>ブラウザで<code>http://localhost:8000</code>にアクセスしてみましょう。</p>
</li>
<li>
<p>何回かアクセスして、ブラウザにアクセス回数が表示されればOKです！尚、ブラウザが自動で<code>/favicon.ico</code>を取得しようとするため、カウントが2つずつカウントアップすることがあります。</p>
</li>
</ol>
<p><img src="./imgs/05_tutorial-access-count.png" alt=""></p>
<h2 id="step-5-html%E3%82%92%E8%A1%A8%E7%A4%BA%E3%81%97%E3%81%A6%E3%81%BF%E3%82%88%E3%81%86">Step 5. HTMLを表示してみよう</h2>
<p>ブラウザにHTMLを表示させてみましょう。レスポンスに<code>h1</code>タグをつけ、ヘッダ情報を指定します。</p>
<p>今回はヘッダ情報の<code>Content-Type</code>に<code>text/html</code>を指定して、ブラウザにHTML形式のデータを返すことを通知します。<code>Content-Type</code>には様々なものがあり、例として以下のようなものが挙げられます。</p>
<table>
<thead>
<tr>
<th>Content-Type</th>
<th>データ</th>
</tr>
</thead>
<tbody>
<tr>
<td>text/html</td>
<td>HTML</td>
</tr>
<tr>
<td>text/css</td>
<td>CSS</td>
</tr>
<tr>
<td>text/javascript</td>
<td>JavaScript</td>
</tr>
<tr>
<td>application/json</td>
<td>JSON形式</td>
</tr>
<tr>
<td>image/jpeg</td>
<td>画像（JPEG）ファイル</td>
</tr>
<tr>
<td>image/png</td>
<td>画像（PNG）ファイル</td>
</tr>
</tbody>
</table>
<ol>
<li><code>server.js</code>ファイルを以下の内容で編集します。</li>
</ol>
<pre class="hljs"><code><div><span class="hljs-deletion">- // アクセス数を保持する変数をグローバル領域に定義</span>
<span class="hljs-deletion">- let count = 0;</span>
<span class="hljs-deletion">- </span>
  // localhostにDenoのHTTPサーバーを展開
  Deno.serve(request =&gt; {
<span class="hljs-deletion">-     count++;</span>
<span class="hljs-deletion">-     return new Response(`Count: ${count}`);</span>
<span class="hljs-addition">+     return new Response(</span>
<span class="hljs-addition">+         // Responseの第一引数にレスポンスのbodyを設置</span>
<span class="hljs-addition">+         "&lt;h1&gt;H1見出しです&lt;/h1&gt;",</span>
<span class="hljs-addition">+         // Responseの第二引数にヘッダ情報等の付加情報を設置</span>
<span class="hljs-addition">+         {</span>
<span class="hljs-addition">+             // レスポンスにヘッダ情報を付加</span>
<span class="hljs-addition">+             headers: {</span>
<span class="hljs-addition">+                 // text/html形式のデータで、文字コードはUTF-8であること</span>
<span class="hljs-addition">+                 "Content-Type": "text/html; charset=utf-8"</span>
<span class="hljs-addition">+             }</span>
<span class="hljs-addition">+         }</span>
<span class="hljs-addition">+     );</span>
  });
</div></code></pre>
<ol start="2">
<li>ブラウザを再読み込みして、<code>H1見出しです</code>と大きく表示されればOKです！</li>
</ol>
<p><img src="./imgs/06_tutorial-h1-tag.png" alt=""></p>
<h2 id="step-6-%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%82%B5%E3%83%BC%E3%83%90%E3%83%BC%E3%82%92%E5%AE%9F%E8%A3%85%E3%81%97%E3%81%A6%E3%81%BF%E3%82%88%E3%81%86">Step 6. ファイルサーバーを実装してみよう</h2>
<h3 id="html%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%82%92%E8%AA%AD%E3%81%BF%E8%BE%BC%E3%82%93%E3%81%A7%E3%81%BF%E3%82%88%E3%81%86">HTMLファイルを読み込んでみよう</h3>
<p>直前のセクションではHTMLを文字列としてスクリプト内に直に記述しましたが、別のファイルとして保存しておいたものを読み込むようにしてみましょう。</p>
<p>また、ファイルの読み込みが完了するまではレスポンスを返さないように、処理に<code>async-await</code>を追加します。JavaScriptでは非同期処理が採用されているため、<code>async-await</code>を記載しなければファイルがうまく表示できない場合があります。</p>
<blockquote>
<p>Topic: 「JavaScript 非同期処理」「JavaScript async await」などで調べてみましょう。</p>
</blockquote>
<ol>
<li><code>public</code>フォルダを作成し、中に<code>index.html</code>を作成します。フォルダ構成は以下のようになります。</li>
</ol>
<pre class="hljs"><code><div>├─ .vscode/
├─ public/
│  └─ index.html
└─ server.js
</div></code></pre>
<ol start="2">
<li><code>index.html</code>ファイルに以下の内容を記述します。</li>
</ol>
<pre class="hljs"><code><div>&lt;!DOCTYPE html&gt;
&lt;html&gt;

&lt;!-- headタグの中にはメタデータ等を記載する --&gt;
&lt;head&gt;
  &lt;meta charset=&quot;utf-8&quot;&gt;
&lt;/head&gt;

&lt;!-- bodyタグの中には実際に表示するものなどを書く --&gt;
&lt;body&gt;
  &lt;h1&gt;H1見出しですよ&lt;/h1&gt;
&lt;/body&gt;

&lt;/html&gt;
</div></code></pre>
<ol start="3">
<li><code>server.js</code>ファイルを以下の内容で編集します。</li>
</ol>
<pre class="hljs"><code><div>  // localhostにDenoのHTTPサーバーを展開
<span class="hljs-deletion">- Deno.serve(request =&gt; {</span>
<span class="hljs-addition">+ Deno.serve(async (request) =&gt; {</span>
<span class="hljs-addition">+     const htmlText = await Deno.readTextFile("./public/index.html");</span>
      return new Response(
          // Responseの第一引数にレスポンスのbodyを設置
<span class="hljs-deletion">-         "&lt;h1&gt;H1見出しです&lt;/h1&gt;",</span>
<span class="hljs-addition">+         htmlText,</span>
          // Responseの第二引数にヘッダ情報等の付加情報を設置
          {
              // レスポンスにヘッダ情報を付加
  ...
</div></code></pre>
<ol start="4">
<li>ブラウザを再読み込みして、<code>H1見出しですよ</code>と大きく表示されればOKです！</li>
</ol>
<p><img src="./imgs/07_tutorial-read-file.png" alt=""></p>
<h3 id="css%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%82%92%E8%AA%AD%E3%81%BF%E8%BE%BC%E3%82%93%E3%81%A7%E3%81%BF%E3%82%88%E3%81%86">CSSファイルを読み込んでみよう</h3>
<p>CSSファイルを作成して、読み込めるようにしてみましょう。<code>index.html</code>とは別に<code>styles.css</code>を作成し、このファイルを読み込めるようにします。</p>
<ol>
<li><code>public</code>フォルダの中に、<code>styles.css</code>を作成します。</li>
</ol>
<pre class="hljs"><code><div>├─ .vscode/
├─ public/
│  ├─ index.html
│  └─ styles.css
└─ server.js
</div></code></pre>
<ol start="2">
<li>各ファイルを、以下のように編集します。</li>
</ol>
<pre class="hljs"><code><div>/* public/styles.css */
body {
    background: skyblue;
}
</div></code></pre>
<pre class="hljs"><code><div>  &lt;!-- public/index.html --&gt;
  ...
  &lt;!-- headタグの中にはメタデータ等を記載する --&gt;
  &lt;head&gt;
    &lt;meta charset="utf-8"&gt;
<span class="hljs-addition">+   &lt;link rel="stylesheet" href="styles.css"&gt;</span>
  &lt;/head&gt;

  &lt;!-- bodyタグの中には実際に表示するものなどを書く --&gt;
  ...
</div></code></pre>
<pre class="hljs"><code><div>  // server.js
  ...
  // localhostにDenoのHTTPサーバーを展開
  Deno.serve(async (request) =&gt; {
<span class="hljs-addition">+     // パス名を取得する</span>
<span class="hljs-addition">+     // http://localhost:8000/hoge に接続した場合"/hoge"が取得できる</span>
<span class="hljs-addition">+     const pathname = new URL(request.url).pathname;</span>
<span class="hljs-addition">+     console.log(`pathname: ${pathname}`);</span>
<span class="hljs-addition">+ </span>
<span class="hljs-addition">+     // http://localhost:8000/styles.css へのアクセス時、"./public/styles.css"を返す</span>
<span class="hljs-addition">+     if (pathname === "/styles.css") {</span>
<span class="hljs-addition">+         const cssText = await Deno.readTextFile("./public/styles.css");</span>
<span class="hljs-addition">+         return new Response(</span>
<span class="hljs-addition">+             cssText,</span>
<span class="hljs-addition">+             {</span>
<span class="hljs-addition">+                 headers: {</span>
<span class="hljs-addition">+                     // text/css形式のデータで、文字コードはUTF-8であること</span>
<span class="hljs-addition">+                     "Content-Type": "text/css; charset=utf-8"</span>
<span class="hljs-addition">+                 }</span>
<span class="hljs-addition">+             }</span>
<span class="hljs-addition">+         );</span>
<span class="hljs-addition">+     }</span>
<span class="hljs-addition">+ </span>
      const htmlText = await Deno.readTextFile("./public/index.html");
      return new Response(
          // Responseの第一引数にレスポンスのbodyを設置
  ...
</div></code></pre>
<ol start="3">
<li>ブラウザを再読み込みして、背景が青くなっていればOKです！</li>
</ol>
<p><img src="./imgs/08_tutorial-read-css-file.png" alt=""></p>
<h3 id="public%E3%83%95%E3%82%A9%E3%83%AB%E3%83%80%E5%85%A8%E4%BD%93%E3%82%92%E5%85%AC%E9%96%8B%E3%81%97%E3%81%A6%E3%81%BF%E3%82%88%E3%81%86">publicフォルダ全体を公開してみよう</h3>
<p>ページ数が増えた場合に、返すファイルを一つ一つ指定するのは手間がかかります。<br>
そこで、<code>public</code>以下を静的ファイルサーバーとして公開し、ここに入れたファイルは自動で公開されるようにしてみましょう。</p>
<ol>
<li><code>server.js</code>ファイルを以下の内容で編集します。</li>
</ol>
<pre class="hljs"><code><div>  // deno.landに公開されているモジュールをimport
  // denoではURLを直に記載してimportできます
<span class="hljs-addition">+ import { serveDir } from "https://deno.land/std@0.223.0/http/file_server.ts";</span>

  // localhostにDenoのHTTPサーバーを展開
  Deno.serve(async (request) =&gt; {
      // パス名を取得する
      // http://localhost:8000/hoge に接続した場合"/hoge"が取得できる
      const pathname = new URL(request.url).pathname;
      console.log(`pathname: ${pathname}`);
  
<span class="hljs-deletion">-     // http://localhost:8000/styles.css へのアクセス時、"./public/styles.css"を返す</span>
<span class="hljs-deletion">-     if (pathname === "/styles.css") {</span>
<span class="hljs-deletion">-         const cssText = await Deno.readTextFile("./public/styles.css");</span>
<span class="hljs-deletion">-         return new Response(</span>
<span class="hljs-deletion">-             cssText,</span>
<span class="hljs-deletion">-             {</span>
<span class="hljs-deletion">-                 headers: {</span>
<span class="hljs-deletion">-                     // text/css形式のデータで、文字コードはUTF-8であること</span>
<span class="hljs-deletion">-                     "Content-Type": "text/css; charset=utf-8"</span>
<span class="hljs-deletion">-                 }</span>
<span class="hljs-deletion">-             }</span>
<span class="hljs-deletion">-         );</span>
<span class="hljs-deletion">-     }</span>
<span class="hljs-deletion">- </span>
<span class="hljs-deletion">-     const htmlText = await Deno.readTextFile("./public/index.html");</span>
<span class="hljs-deletion">-     return new Response(</span>
<span class="hljs-deletion">-         // Responseの第一引数にレスポンスのbodyを設置</span>
<span class="hljs-deletion">-         htmlText,</span>
<span class="hljs-deletion">-         // Responseの第二引数にヘッダ情報等の付加情報を設置</span>
<span class="hljs-deletion">-             // レスポンスにヘッダ情報を付加</span>
<span class="hljs-deletion">-             headers: {</span>
<span class="hljs-deletion">-                 // text/html形式のデータで、文字コードはUTF-8であること</span>
<span class="hljs-deletion">-                 "Content-Type": "text/html; charset=utf-8"</span>
<span class="hljs-deletion">-             }</span>
<span class="hljs-deletion">-     );</span>
<span class="hljs-addition">+     // ./public以下のファイルを公開</span>
<span class="hljs-addition">+     return serveDir(</span>
<span class="hljs-addition">+         request,</span>
<span class="hljs-addition">+         {</span>
<span class="hljs-addition">+             /*</span>
<span class="hljs-addition">+             - fsRoot: 公開するフォルダを指定</span>
<span class="hljs-addition">+             - urlRoot: フォルダを展開するURLを指定。今回はlocalhost:8000/に直に展開する</span>
<span class="hljs-addition">+             - enableCors: CORSの設定を付加するか</span>
<span class="hljs-addition">+             */</span>
<span class="hljs-addition">+             fsRoot: "./public/",</span>
<span class="hljs-addition">+             urlRoot: "",</span>
<span class="hljs-addition">+             enableCors: true,</span>
<span class="hljs-addition">+         }</span>
<span class="hljs-addition">+     );</span>
  
  });
</div></code></pre>
<ol start="2">
<li>ブラウザを再読み込みして、先程と同じ内容が表示されればOKです！</li>
</ol>
<h2 id="step-7-%E3%83%96%E3%83%A9%E3%82%A6%E3%82%B6%E3%81%A7javascript%E3%82%92%E5%AE%9F%E8%A1%8C%E3%81%97%E3%81%A6%E3%81%BF%E3%82%88%E3%81%86">Step 7. ブラウザでJavaScriptを実行してみよう</h2>
<p>ブラウザでJavaScriptを実行してみましょう。<code>alert</code>関数を使用して、ブラウザ上でアラートを出力します。</p>
<p>今回は簡単のため、HTMLファイルに直に処理を記述します。</p>
<ol>
<li><code>public/index.html</code>ファイルを以下の内容で編集します。</li>
</ol>
<pre class="hljs"><code><div>  &lt;!-- bodyタグの中には実際に表示するものなどを書く --&gt;
  &lt;body&gt;
    &lt;h1&gt;H1見出しですよ&lt;/h1&gt;
<span class="hljs-addition">+ </span>
<span class="hljs-addition">+   &lt;!-- JavaScriptを実行 --&gt;</span>
<span class="hljs-addition">+   &lt;script&gt;</span>
<span class="hljs-addition">+     alert("Hello JavaScript!");</span>
<span class="hljs-addition">+   &lt;/script&gt;</span>
  &lt;/body&gt;
  
  &lt;/html&gt;
</div></code></pre>
<ol start="2">
<li>ブラウザを再読み込みして、アラートが表示されればOKです！</li>
</ol>
<p><img src="./imgs/09_tutorial-javascript-alert.png" alt=""></p>
<h2 id="step-8-%E3%81%97%E3%82%8A%E3%81%A8%E3%82%8A%E3%81%AE%E5%AE%9F%E8%A3%85-%E3%82%B5%E3%83%BC%E3%83%90%E3%83%BC%E3%81%AE%E5%87%A6%E7%90%86%E3%82%92%E5%AE%9F%E8%A3%85%E3%81%97%E3%81%A6%E3%81%BF%E3%82%88%E3%81%86">Step 8. しりとりの実装: サーバーの処理を実装してみよう</h2>
<p>ここからは、実際に「しりとり」をするWebアプリを実装します。
実装するアプリは、以下の仕様を満たしたものとします。</p>
<ol>
<li>直前の単語が表示できる。</li>
<li>次の単語を入力できる。</li>
<li>直前の単語の末尾と入力した単語の先頭が同一であれば、単語を更新。同一でなければ、エラーを表示する。</li>
</ol>
<p>このセクションでは、サーバー側の処理を実装します。前セクションまでで実装した内容をベースにして実装を進めましょう。</p>
<h3 id="get-shiritori%E3%82%92%E5%AE%9F%E8%A3%85%E3%81%97%E3%82%88%E3%81%86"><code>GET /shiritori</code>を実装しよう</h3>
<p>仕様1を満たすため、サーバーに保存されている直前の単語を取得できるようにしましょう。</p>
<p><code>GET /shiritori</code>からデータを取得できるようにします。</p>
<ol>
<li><code>server.js</code>ファイルを以下の内容で編集します。</li>
</ol>
<pre class="hljs"><code><div>  ...
  import { serveDir } from "https://deno.land/std@0.223.0/http/file_server.ts";
  
<span class="hljs-addition">+ // 直前の単語を保持しておく</span>
<span class="hljs-addition">+ let previousWord = "しりとり";</span>
<span class="hljs-addition">+ </span>
  // localhostにDenoのHTTPサーバーを展開
  Deno.serve(async (request) =&gt; {
      // パス名を取得する
      // http://localhost:8000/hoge に接続した場合"/hoge"が取得できる
      const pathname = new URL(request.url).pathname;
      console.log(`pathname: ${pathname}`);
  
<span class="hljs-addition">+     // GET /shiritori: 直前の単語を返す</span>
<span class="hljs-addition">+     if (request.method === "GET" &amp;&amp; pathname === "/shiritori") {</span>
<span class="hljs-addition">+         return new Response(previousWord);</span>
<span class="hljs-addition">+     }</span>
<span class="hljs-addition">+ </span>
      // ./public以下のファイルを公開
      return serveDir(
          request,
  ...	
</div></code></pre>
<ol start="2">
<li>ブラウザで<code>http://localhost:8000/shiritori</code>にアクセスして、「しりとり」と表示されればOKです！</li>
</ol>
<h3 id="post-shiritori%E3%82%92%E5%AE%9F%E8%A3%85%E3%81%97%E3%82%88%E3%81%86"><code>POST /shiritori</code>を実装しよう</h3>
<p>仕様2を満たすため、サーバーに保存されている単語を、受け取ったデータで更新できるようにしましょう。</p>
<p><code>POST /shiritori</code>でデータを更新できるようにします。</p>
<ol>
<li><code>server.js</code>ファイルを以下の内容で編集します。</li>
</ol>
<pre class="hljs"><code><div>      // GET /shiritori: 直前の単語を返す
      if (request.method <span class="hljs-comment">=== "GET" &amp;&amp; pathname === "/shiritori") {</span>
          return new Response(previousWord);
      }
  
<span class="hljs-addition">+     // POST /shiritori: 次の単語を入力する</span>
<span class="hljs-addition">+     if (request.method === "POST" &amp;&amp; pathname === "/shiritori") {</span>
<span class="hljs-addition">+         // リクエストのペイロードを取得</span>
<span class="hljs-addition">+         const requestJson = await request.json();</span>
<span class="hljs-addition">+         // JSONの中からnextWordを取得</span>
<span class="hljs-addition">+         const nextWord = requestJson["nextWord"];</span>
<span class="hljs-addition">+ </span>
<span class="hljs-addition">+         // previousWordの末尾とnextWordの先頭が同一か確認</span>
<span class="hljs-addition">+         if (previousWord.slice(-1) === nextWord.slice(0, 1)) {</span>
<span class="hljs-addition">+             // 同一であれば、previousWordを更新</span>
<span class="hljs-addition">+             previousWord = nextWord;</span>
<span class="hljs-addition">+         }</span>
<span class="hljs-addition">+ </span>
<span class="hljs-addition">+         // 現在の単語を返す</span>
<span class="hljs-addition">+         return new Response(previousWord);</span>
<span class="hljs-addition">+     }</span>
<span class="hljs-addition">+ </span>
      // ./public以下のファイルを公開
      return serveDir(
          request,
</div></code></pre>
<ol start="2">
<li><code>POST</code>のリクエストの送信は専用のツールやOSによって異なるコマンドが必要なので、動作確認はスキップして、次のセクションに進みましょう。もし動作確認の方法が分かるようであれば、動作確認してみてください。</li>
</ol>
<h2 id="step-9-%E3%81%97%E3%82%8A%E3%81%A8%E3%82%8A%E3%81%AE%E5%AE%9F%E8%A3%85-web%E3%81%AE%E5%87%A6%E7%90%86%E3%82%92%E5%AE%9F%E8%A3%85%E3%81%97%E3%81%A6%E3%81%BF%E3%82%88%E3%81%86">Step 9. しりとりの実装: Webの処理を実装してみよう</h2>
<p>前セクションの内容を踏まえて、Web側の処理を実装しましょう。</p>
<h3 id="get-shiritori%E3%81%AE%E7%B5%90%E6%9E%9C%E3%82%92%E8%A1%A8%E7%A4%BA%E3%81%99%E3%82%8B"><code>GET /shiritori</code>の結果を表示する</h3>
<p><code>GET /shiritori</code>にアクセスして、直前の単語を取得します。以下のようにして実装してみましょう。</p>
<ol>
<li><code>public/index.html</code>ファイルを以下の内容で編集します。<code>fetch</code>を利用して<code>GET /shiritori</code>にリクエストを送信し、受信したデータを<code>p</code>タグに挿入します。</li>
</ol>
<pre class="hljs"><code><div>  ...
  &lt;!-- bodyタグの中には実際に表示するものなどを書く --&gt;
  &lt;body&gt;
<span class="hljs-deletion">-   &lt;h1&gt;H1見出しですよ&lt;/h1&gt;</span>
<span class="hljs-addition">+   &lt;h1&gt;しりとり&lt;/h1&gt;</span>
<span class="hljs-addition">+   &lt;!-- 現在の単語を表示する場所 --&gt;</span>
<span class="hljs-addition">+   &lt;p id="previousWord"&gt;&lt;/p&gt;</span>
  
    &lt;!-- JavaScriptを実行 --&gt;
    &lt;script&gt;
<span class="hljs-deletion">-     alert("Hello JavaScript!");</span>
<span class="hljs-addition">+     window.onload = async (event) =&gt; {</span>
<span class="hljs-addition">+       // GET /shiritoriを実行</span>
<span class="hljs-addition">+       const response = await fetch("/shiritori", { method: "GET" });</span>
<span class="hljs-addition">+       // responseの中からレスポンスのテキストデータを取得</span>
<span class="hljs-addition">+       const previousWord = await response.text();</span>
<span class="hljs-addition">+       // id: previousWordのタグを取得</span>
<span class="hljs-addition">+       const paragraph = document.querySelector("#previousWord");</span>
<span class="hljs-addition">+       // 取得したタグの中身を書き換える</span>
<span class="hljs-addition">+       paragraph.innerHTML = `前の単語: ${previousWord}`;</span>
<span class="hljs-addition">+     }</span>
    &lt;/script&gt;
  &lt;/body&gt;
...
</div></code></pre>
<ol start="2">
<li>ブラウザを<code>http://localhost:8000</code>で再読み込みして、「しりとり」と表示されればOKです！</li>
</ol>
<blockquote>
<p>Topic: サーバー側の<code>previousWord</code>を書き換えて、反映されるか確認してみましょう。</p>
</blockquote>
<h3 id="%E8%B5%B7%E5%8B%95%E6%99%82%E3%81%ABpost-shiritori%E3%81%AB%E6%AC%A1%E3%81%AE%E5%8D%98%E8%AA%9E%E3%82%92%E9%80%81%E4%BF%A1%E3%81%97%E3%81%A6%E3%81%BF%E3%82%88%E3%81%86">（起動時に）<code>POST /shiritori</code>に次の単語を送信してみよう</h3>
<p><code>POST /shiritori</code>にアクセスして、次の単語を入力してみましょう。ここでは、ブラウザの起動時に勝手に「りんご」と送信されるようにしてみます。</p>
<ol>
<li><code>public/index.html</code>ファイルを以下の内容で編集します。<code>GET</code>同様、<code>fetch</code>を使用して<code>POST /shiritori</code>にリクエストを送信します。</li>
</ol>
<pre class="hljs"><code><div>    &lt;!-- JavaScriptを実行 --&gt;
    &lt;script&gt;
      window.onload = async (event) =&gt; {
<span class="hljs-addition">+       // 試しでPOST /shiritoriを実行してみる</span>
<span class="hljs-addition">+       // りんごと入力……</span>
<span class="hljs-addition">+       await fetch(</span>
<span class="hljs-addition">+         "/shiritori",</span>
<span class="hljs-addition">+         {</span>
<span class="hljs-addition">+           method: "POST",</span>
<span class="hljs-addition">+           headers: { "Content-Type": "application/json" },</span>
<span class="hljs-addition">+           body: JSON.stringify({ nextWord: "りんご" })</span>
<span class="hljs-addition">+         }</span>
<span class="hljs-addition">+       );</span>
<span class="hljs-addition">+ </span>
        // GET /shiritoriを実行
        const response = await fetch("/shiritori", { method: "GET" });
        // responseの中からレスポンスのテキストデータを取得
</div></code></pre>
<ol start="2">
<li>ブラウザを再読み込みして、「りんご」と表示されればOKです！</li>
</ol>
<blockquote>
<p>Topic: サーバー側の<code>previousWord</code>やWeb側の<code>nextWord</code>を書き換えて、反映されるか確認してみましょう。しりとりとして単語が繋がっていなければ、更新されないようになっていることも確認しましょう。</p>
</blockquote>
<h3 id="post-shiritori%E3%81%AB%E4%BB%BB%E6%84%8F%E3%81%AE%E5%8D%98%E8%AA%9E%E3%82%92%E9%80%81%E4%BF%A1%E3%81%97%E3%81%A6%E3%81%BF%E3%82%88%E3%81%86"><code>POST /shiritori</code>に任意の単語を送信してみよう</h3>
<p>起動時にサーバーの値を書き換えることができました。次に、任意の単語を送信できるようにしてみましょう。</p>
<ol>
<li><code>public/index.html</code>ファイルを以下の内容で編集します。送信ボタンが押下された時に<code>input</code>タグの中身を取得して、<code>POST /shiritori</code>に送信します。</li>
</ol>
<pre class="hljs"><code><div>   &lt;h1&gt;しりとり&lt;/h1&gt;
    &lt;!-- 現在の単語を表示する場所 --&gt;
    &lt;p id="previousWord"&gt;&lt;/p&gt;
<span class="hljs-addition">+   &lt;!-- 次の文字を入力するフォーム --&gt;</span>
<span class="hljs-addition">+   &lt;input id="nextWordInput" type="text" /&gt;</span>
<span class="hljs-addition">+   &lt;button id="nextWordSendButton"&gt;送信&lt;/button&gt;</span>
  
    &lt;!-- JavaScriptを実行 --&gt;
    &lt;script&gt;
      window.onload = async (event) =&gt; {
<span class="hljs-deletion">-       // 試しでPOST /shiritoriを実行してみる</span>
<span class="hljs-deletion">-       // りんごと入力……</span>
<span class="hljs-deletion">-       await fetch(</span>
<span class="hljs-deletion">-         "/shiritori",</span>
<span class="hljs-deletion">-         {</span>
<span class="hljs-deletion">-           method: "POST",</span>
<span class="hljs-deletion">-           headers: { "Content-Type": "application/json" },</span>
<span class="hljs-deletion">-           body: JSON.stringify({ nextWord: "りんご" })</span>
<span class="hljs-deletion">-         }</span>
<span class="hljs-deletion">-       );</span>
        // GET /shiritoriを実行
        const response = await fetch("/shiritori", { method: "GET" });
        // responseの中からレスポンスのテキストデータを取得
        const previousWord = await response.text();
        // id: previousWordのタグを取得
        const paragraph = document.querySelector("#previousWord");
        // 取得したタグの中身を書き換える
        paragraph.innerHTML = `前の単語: ${previousWord}`;
      }
  
<span class="hljs-addition">+     // 送信ボタンの押下時に実行</span>
<span class="hljs-addition">+     document.querySelector("#nextWordSendButton").onclick = async(event) =&gt; {</span>
<span class="hljs-addition">+       // inputタグを取得</span>
<span class="hljs-addition">+       const nextWordInput = document.querySelector("#nextWordInput");</span>
<span class="hljs-addition">+       // inputの中身を取得</span>
<span class="hljs-addition">+       const nextWordInputText = nextWordInput.value;</span>
<span class="hljs-addition">+       // POST /shiritoriを実行</span>
<span class="hljs-addition">+       // 次の単語をresponseに格納</span>
<span class="hljs-addition">+       const response = await fetch(</span>
<span class="hljs-addition">+         "/shiritori",</span>
<span class="hljs-addition">+         {</span>
<span class="hljs-addition">+           method: "POST",</span>
<span class="hljs-addition">+           headers: { "Content-Type": "application/json" },</span>
<span class="hljs-addition">+           body: JSON.stringify({ nextWord: nextWordInputText })</span>
<span class="hljs-addition">+         }</span>
<span class="hljs-addition">+       );</span>
<span class="hljs-addition">+ </span>
<span class="hljs-addition">+       const previousWord = await response.text();</span>
<span class="hljs-addition">+ </span>
<span class="hljs-addition">+       // id: previousWordのタグを取得</span>
<span class="hljs-addition">+       const paragraph = document.querySelector("#previousWord");</span>
<span class="hljs-addition">+       // 取得したタグの中身を書き換える</span>
<span class="hljs-addition">+       paragraph.innerHTML = `前の単語: ${previousWord}`;</span>
<span class="hljs-addition">+       // inputタグの中身を消去する</span>
<span class="hljs-addition">+       nextWordInput.value = "";</span>
<span class="hljs-addition">+     }</span>
    &lt;/script&gt;
  &lt;/body&gt;
</div></code></pre>
<ol start="2">
<li>ブラウザを読み込み直して、入力フォームが表示されていればOKです！</li>
</ol>
<blockquote>
<p>Topic: 単語を色々入力して、しりとりとして成立しているか確認してみましょう。</p>
</blockquote>
<h2 id="step-10-%E3%81%97%E3%82%8A%E3%81%A8%E3%82%8A%E3%81%AE%E5%AE%9F%E8%A3%85-%E3%82%A8%E3%83%A9%E3%83%BC%E3%82%92%E5%AE%9F%E8%A3%85%E3%81%97%E3%81%A6%E3%81%BF%E3%82%88%E3%81%86">Step 10. しりとりの実装: エラーを実装してみよう</h2>
<p>「りんご」の次に「らっぱ」などの続かない単語が入力された時に、エラーを表示できるようにしてみましょう。ここでは、<code>application/json</code>形式のデータを返すようにしてみます。Webとサーバーを以下のように書き換えてください。</p>
<ol>
<li><code>server.js</code>ファイルを以下の内容で編集します。</li>
</ol>
<pre class="hljs"><code><div>      // POST /shiritori: 次の単語を入力する
      if (request.method <span class="hljs-comment">=== "POST" &amp;&amp; pathname === "/shiritori") {</span>
          // リクエストのペイロードを取得
          const requestJson = await request.json();
          // JSONの中からnextWordを取得
          const nextWord = requestJson["nextWord"];
          // previousWordの末尾とnextWordの先頭が同一か確認
          if (previousWord.slice(-1) <span class="hljs-comment">=== nextWord.slice(0, 1)) {</span>
              // 同一であれば、previousWordを更新
              previousWord = nextWord;
          }
<span class="hljs-addition">+         // 同一でない単語の入力時に、エラーを返す</span>
<span class="hljs-addition">+         else {</span>
<span class="hljs-addition">+             return new Response(</span>
<span class="hljs-addition">+                 JSON.stringify({</span>
<span class="hljs-addition">+                     "errorMessage": "前の単語に続いていません",</span>
<span class="hljs-addition">+                     "errorCode": "10001"</span>
<span class="hljs-addition">+                 }),</span>
<span class="hljs-addition">+                 {</span>
<span class="hljs-addition">+                     status: 400,</span>
<span class="hljs-addition">+                     headers: { "Content-Type": "application/json; charset=utf-8" },</span>
<span class="hljs-addition">+                 }</span>
<span class="hljs-addition">+             );</span>
<span class="hljs-addition">+         }</span>
</div></code></pre>
<ol start="2">
<li><code>public/index.html</code>ファイルを以下の内容で編集します。</li>
</ol>
<pre class="hljs"><code><div>      // 送信ボタンの押下時に実行
      document.querySelector("#nextWordSendButton").onclick = async(event) =&gt; {
        // inputタグを取得
        const nextWordInput = document.querySelector("#nextWordInput");
        // inputの中身を取得
        const nextWordInputText = nextWordInput.value;
        // POST /shiritoriを実行
        // 次の単語をresponseに格納
        const response = await fetch(
          "/shiritori",
          {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ nextWord: nextWordInputText })
          }
        );
<span class="hljs-addition">+ </span>
<span class="hljs-addition">+       // status: 200以外が返ってきた場合にエラーを表示</span>
<span class="hljs-addition">+       if (response.status !== 200) {</span>
<span class="hljs-addition">+         const errorJson = await response.text();</span>
<span class="hljs-addition">+         const errorObj = JSON.parse(errorJson);</span>
<span class="hljs-addition">+         alert(errorObj["errorMessage"]);</span>
<span class="hljs-addition">+       }</span>
  
        const previousWord = await response.text();
</div></code></pre>
<ol start="3">
<li>ブラウザを再読み込みして、不正な単語を入力してみましょう。アラートが表示されればOKです！</li>
</ol>
<h2 id="step-11-github%E3%81%AE%E3%83%AA%E3%83%9D%E3%82%B8%E3%83%88%E3%83%AA%E3%82%92%E4%BD%9C%E3%82%8D%E3%81%86">Step 11. GitHubのリポジトリを作ろう</h2>
<p>作成したWebアプリをGitHubリポジトリに保存し、コードを公開しましょう。</p>
<p>GitHubは、Gitのリポジトリをインターネット上で管理するためのサービスです。リポジトリをアップロードしておくことで、複数人での開発時のソースコードの共有、ソースコードのバックアップ、ご自身の実績の公開の場として、などの効果を期待できます。</p>
<p>GitHubアカウントでログインしてリポジトリを作成し、成果物をアップロードしてみましょう。</p>
<ol>
<li>GitHubの新規リポジトリを作りましょう。<a href="https://github.com/new">https://github.com/new</a>にアクセスして、任意のリポジトリ名を入力、公開状態は「Public」としてください。他の設定は触らなくて大丈夫です。</li>
</ol>
<p><img src="./imgs/10_github-new-project.png" alt=""></p>
<ol start="2">
<li>以下のような画面になれば、リポジトリの完成です。任意の方法で、GitHubにソースコードをプッシュしてみましょう。CUIで操作する場合は、GitHubの画面に表示されているコマンドを実行すればOKです。</li>
</ol>
<p><img src="./imgs/11_github-initialize-project.png" alt=""></p>
<ol start="3">
<li>以下の例では、<code>README.md</code>も一緒にプッシュしてみました。GitHubでは、<code>README.md</code>に記述した内容が画面下部に表示されます。ここに環境構築手順やリポジトリの説明等を記載すると分かりやすいです。</li>
</ol>
<p><img src="./imgs/12_github-pushed.png" alt=""></p>
<h2 id="step-12-deno-deploy%E3%81%AB%E3%83%87%E3%83%97%E3%83%AD%E3%82%A4%E3%81%97%E3%81%A6%E3%81%BF%E3%82%88%E3%81%86">Step 12. Deno Deployにデプロイしてみよう</h2>
<blockquote>
<p>注意
GitHubアカウントの作成後、一週間程はDeno Deployの登録ができません。登録できない場合は、Step 12はスキップしてStep 13を先に終わらせてください。</p>
</blockquote>
<h3 id="deno-deploy%E3%81%AE%E3%82%A2%E3%82%AB%E3%82%A6%E3%83%B3%E3%83%88%E7%99%BB%E9%8C%B2%E3%82%92%E3%81%97%E3%82%88%E3%81%86">Deno Deployのアカウント登録をしよう</h3>
<p>Deno Deployでアカウント登録しましょう。Deno DeployのアカウントはGitHubアカウントと連携する形で作成できるので、先に作成したGitHubアカウントを使用してください。</p>
<p><a href="https://deno.com/deploy">https://deno.com/deploy</a></p>
<p><img src="./imgs/13_deno-home.png" alt="">
<img src="./imgs/14_deno-github.png" alt=""></p>
<h3 id="deno-deploy%E3%81%AE%E3%83%97%E3%83%AD%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%82%92%E4%BD%9C%E6%88%90%E3%81%97%E3%82%88%E3%81%86">Deno Deployのプロジェクトを作成しよう</h3>
<p>早速、Deno Deployのプロジェクトを作ってみましょう。</p>
<p>GitHubのリポジトリを元に、Deno Deployのプロジェクトを作成します。</p>
<ol>
<li>「New Project」をクリックして、新規プロジェクトの作成画面を開きましょう。</li>
</ol>
<p><img src="./imgs/15_deno-deploy-home.png" alt=""></p>
<ol start="2">
<li>「Select User or Organization」から「Add Github Account」を選択します。</li>
</ol>
<p><img src="./imgs/16_deno-deploy-select-user.png" alt=""></p>
<ol start="3">
<li>Deno Deployから全てのリポジトリへのアクセスを許可する場合は「All repositories」、一部のリポジトリにのみ絞りたい場合は「Only select repositories」を選択して、作成したWebアプリのリポジトリを指定しましょう。</li>
</ol>
<p><img src="./imgs/17_deno-deploy-github-install.png" alt=""></p>
<ol start="4">
<li>以下のようにアカウント設定、リポジトリを指定し、「Entrypoint」には<code>server.js</code>を指定して、「Deploy Project」をクリックします。</li>
</ol>
<p><img src="./imgs/18_deno-create-new-project-1.png" alt="">
<img src="./imgs/19_deno-create-new-project-2.png" alt=""></p>
<blockquote>
<p>Topic: Entrypointに指定したDenoファイルが、サーバー起動時に自動で実行されます。</p>
</blockquote>
<ol start="5">
<li>しばらくするとデプロイが完了します。以下の画像の二枚目の画面になったら、完了です。表示されているリンクをクリックしてWebサイトを開いてみましょう！</li>
</ol>
<p><img src="./imgs/20_deno-deploying.png" alt="">
<img src="./imgs/21_deno-deploy-success.png" alt="">
<img src="./imgs/22_deno-deploy-web-site.png" alt=""></p>
<h2 id="step13-%E3%81%8A%E3%82%8F%E3%82%8A%E3%81%AB">Step13. おわりに</h2>
<p>ここまでで、Deno DeployにWebアプリケーションをデプロイして動作させることができました。Deno DeployはGitHubと連携していますので、GitHubを更新すれば自動で修正された内容がデプロイされるようになっています。</p>
<p>このまま実装を進めて、課題として示されたアプリケーションの仕様を満たしたものを実装してみましょう。<br>
以降はご自身で実装を進めていただきますが、次セクションに実装のヒントを記載していますので、参考にしても構いません。</p>
<p>必須仕様を満たした上で、便利・面白いと思う任意の機能を実装したら完成です。
アプリケーションが完成したら、<code>README</code>を記載して、Google フォームから提出してください。</p>
<h2 id="step-14-%E5%AE%9F%E8%A3%85%E3%81%AE%E3%83%92%E3%83%B3%E3%83%88">Step 14. 実装のヒント</h2>
<p>ここでは、必須仕様を満たすための実装のヒントを掲載します。</p>
<h3 id="%E5%AE%9F%E8%A3%85%E3%81%AE%E4%BE%8B">実装の例</h3>
<p>以下のWebサイトに必須仕様を満たすWebアプリケーションをデプロイしました。実装の参考にしてみてください。
尚、課題に記載していなかった詳細な仕様については自身で検討して実装していますが、以下に示すのはあくまでも一例ですので、従う必要はありません。</p>
<p><a href="https://niba2828-deno-shirit-12.deno.dev/">https://niba2828-deno-shirit-12.deno.dev/</a></p>
<h3 id="%22%E6%9C%AB%E5%B0%BE%E3%81%8C%E3%82%93%E3%81%A7%E7%B5%82%E3%82%8F%E3%82%8B%E5%8D%98%E8%AA%9E%E3%81%8C%E5%85%A5%E5%8A%9B%E3%81%95%E3%82%8C%E3%81%9F%E3%82%89%E3%82%B2%E3%83%BC%E3%83%A0%E3%82%92%E7%B5%82%E4%BA%86%E3%81%99%E3%82%8B%22">&quot;末尾が「ん」で終わる単語が入力されたら、ゲームを終了する&quot;</h3>
<h4 id="hint1-%E5%87%A6%E7%90%86%E3%82%92%E8%BF%BD%E5%8A%A0%E3%81%99%E3%82%8B%E5%A0%B4%E6%89%80">Hint1: 処理を追加する場所</h4>
<p><code>POST /shiritori</code>を実行した際の処理を修正して、以下の部分に処理を追加するとよさそうです。</p>
<pre class="hljs"><code><div>// server.js
  ...
          // previousWordの末尾とnextWordの先頭が同一か確認
          if (previousWord.slice(-1) <span class="hljs-comment">=== nextWord.slice(0, 1)) {</span>
<span class="hljs-addition">+             // 末尾が「ん」になっている場合</span>
<span class="hljs-addition">+             // ifの中に入力された単語の末尾が「ん」になっていることを確認する条件式を追加</span>
<span class="hljs-addition">+             if (...) {</span>
<span class="hljs-addition">+                 // エラーを返す処理を追加</span>
<span class="hljs-addition">+                 // errorCodeを固有のものにして、末尾が「ん」の時に発生したエラーだとWeb側に通知できるようにする</span>
<span class="hljs-addition">+             }</span>
<span class="hljs-addition">+ </span>
              // 同一であれば、previousWordを更新
              previousWord = nextWord;
          }
  ...
</div></code></pre>
<pre class="hljs"><code><div>// index.html
  ...
        if (response.status !== 200) {
          const errorJson = await response.text();
          const errorObj = JSON.parse(errorJson);
<span class="hljs-addition">+         // errorObj["errorCode"]ごとに処理を分岐する</span>
<span class="hljs-addition">+         // errorCodeが、末尾が「ん」の時のエラーだったら、ゲームを終了する</span>
          return;
        }
  ...
</div></code></pre>
<h4 id="hint2-%E3%82%B2%E3%83%BC%E3%83%A0%E7%B5%82%E4%BA%86%E6%99%82%E3%81%AEweb%E7%94%BB%E9%9D%A2%E8%A1%A8%E7%A4%BA">Hint2: ゲーム終了時のWeb画面表示</h4>
<p>ゲームの終了時には、ゲームが終了したことを画面に表示するとよさそうです。</p>
<p>ゲームの終了を画面に表示する方法として、以下のものが考えられます。</p>
<ol>
<li>表示文言を修正して、入力フォームを削除する。</li>
<li>終了用の画面に遷移する。</li>
</ol>
<p>1の場合は、HTMLタグの操作や削除など、ここまでに実装した内容の応用で実装が可能です。<br>
2の場合は、HTMLファイルを新しく作成し、ゲーム終了時にゲーム終了画面に遷移するようにすれば実装可能です。</p>
<h3 id="%22%E9%81%8E%E5%8E%BB%E3%81%AB%E4%BD%BF%E7%94%A8%E3%81%97%E3%81%9F%E5%8D%98%E8%AA%9E%E3%81%8C%E5%85%A5%E5%8A%9B%E3%81%95%E3%82%8C%E3%81%9F%E3%82%89%E3%82%B2%E3%83%BC%E3%83%A0%E3%82%92%E7%B5%82%E4%BA%86%E3%81%99%E3%82%8B%22">&quot;過去に使用した単語が入力されたら、ゲームを終了する&quot;</h3>
<h4 id="hint1-%E5%87%A6%E7%90%86%E3%82%92%E8%BF%BD%E5%8A%A0%E3%81%99%E3%82%8B%E5%A0%B4%E6%89%80">Hint1: 処理を追加する場所</h4>
<p>処理を追加する場所は、末尾が「ん」の場合の処理と殆ど変わりません。新しいエラーの処理を実装しましょう。
また、直前より前の単語を保存しておく必要がありますので、その点の処理を追記しましょう。</p>
<h4 id="hint2-%E7%9B%B4%E5%89%8D%E3%82%88%E3%82%8A%E5%89%8D%E3%81%AE%E5%8D%98%E8%AA%9E%E3%82%92%E4%BF%9D%E5%AD%98%E3%81%99%E3%82%8B">Hint2: 直前より前の単語を保存する</h4>
<p>今までは、直前の単語のみを保存して入力した単語と比較していました。しかし、入力した単語が既に使われているかを確認するには、今までの単語を全て記録しておく必要があります。</p>
<p>そこで、JavaScriptのリストを使用して今までの単語を保存しておきましょう。以下のようにして、単語の保存用の変数をリストにしておき、<strong>単語の更新時に逐次保存する</strong>ようにしておけばよさそうです。</p>
<pre class="hljs"><code><div><span class="hljs-deletion">- let previousWord = "しりとり";</span>
<span class="hljs-addition">+ let wordHistories = ["しりとり"];</span>
</div></code></pre>
<p>また、もし余裕があれば、新しくサーバーを作ったりSaaSを使ったりして、データベース等を使用してみるのも良いかもしれません。</p>
<h3 id="%22%E3%82%B2%E3%83%BC%E3%83%A0%E4%B8%AD%E3%82%84%E7%B5%82%E4%BA%86%E5%BE%8C%E3%81%AB%E6%9C%80%E5%88%9D%E3%81%8B%E3%82%89%E3%82%84%E3%82%8A%E7%9B%B4%E3%81%9B%E3%82%8B%E3%83%AA%E3%82%BB%E3%83%83%E3%83%88%E6%A9%9F%E8%83%BD%E3%82%92%E3%81%A4%E3%81%91%E3%82%8B%22">&quot;ゲーム中や終了後に、最初からやり直せるリセット機能をつける&quot;</h3>
<h4 id="hint1-%E5%87%A6%E7%90%86%E3%82%92%E8%BF%BD%E5%8A%A0%E3%81%99%E3%82%8B%E5%A0%B4%E6%89%80">Hint1: 処理を追加する場所</h4>
<p>サーバーに、<code>POST /reset</code>等の新しい<code>POST</code>メソッドを追加しましょう。また、追加した<code>POST</code>メソッドを実行するためのボタンをWebに追加しましょう。</p>
<pre class="hljs"><code><div>// server.js
  ...
          return new Response(previousWord);
      }

<span class="hljs-addition">+     // POST /reset: リセットする</span>
<span class="hljs-addition">+     // request.methodとpathnameを確認</span>
<span class="hljs-addition">+     if (...) {</span>
<span class="hljs-addition">+         // 既存の単語の履歴を初期化する</span>
<span class="hljs-addition">+         // 初期化した単語を返す</span>
<span class="hljs-addition">+     }</span>
<span class="hljs-addition">+ </span>
      // ./public以下のファイルを公開
      return serveDir(
          request,
  ...
</div></code></pre>
<pre class="hljs"><code><div>// index.html
  ...
    &lt;!-- 次の文字を入力するフォーム --&gt;
    &lt;input id="nextWordInput" type="text" /&gt;
    &lt;button id="nextWordSendButton"&gt;送信&lt;/button&gt;
<span class="hljs-addition">+   &lt;button id="resetSendButton"&gt;リセット&lt;/button&gt;</span>
  ...
        // inputタグの中身を消去する
        nextWordInput.value = "";
      }

<span class="hljs-addition">+     // 送信ボタンの押下時に実行</span>
<span class="hljs-addition">+     document.querySelector("#resetSendButton").onclick = async(event) =&gt; {</span>
<span class="hljs-addition">+       // POST /resetを実行</span>
<span class="hljs-addition">+       // ページをリロードする</span>
<span class="hljs-addition">+     }</span>
    &lt;/script&gt;
  ...
</div></code></pre>
<h4 id="hint2-%E3%83%9A%E3%83%BC%E3%82%B8%E3%82%92%E3%83%AA%E3%83%AD%E3%83%BC%E3%83%89%E3%81%99%E3%82%8B">Hint2: ページをリロードする</h4>
<p>リセット処理後、必要であればページをリロードして、Webサイトの表示をリセットしましょう。ゲーム終了時に要素を削除していた場合は、リロードの処理が必要になるかと思います。</p>
<p>JavaScriptの関数を検索して、処理を追記してみましょう。</p>

</body>
</html>
